#pragma once
#include <algorithm>

/////////////////////
// Envelope Filter //
///////////////////////////////////////////////////////////////////////////////////////////////
// This is where we affect the attack, decay, sustain, and release of a wave                 //
// generated by the oscillator. This is the second step in any basic sound synthesis system. //
///////////////////////////////////////////////////////////////////////////////////////////////
class EnvelopeFilter
{
public:
    // ADSR
    void SetSampleRate(const double sample_rate) { m_sample_rate = sample_rate; }
    void SetAttack(const double seconds) { m_attack = seconds * m_sample_rate; }
    void SetDecay(const double seconds) { m_decay = seconds * m_sample_rate; }
    void SetSustain(const double level) { m_sustain = std::clamp(level, 0.0, 1.0); }
    void SetRelease(const double seconds) { m_release = seconds * m_sample_rate; }

    // note playback
    void NoteOn()
    {
        m_state = Attack;
        m_sample_index = 0;
    }

    void NoteOff()
    {
        m_state = Release;
        m_release_amplitude = m_amplitude;
        m_sample_index = 0;
    }

    float GetNextSample()
    {
        switch (m_state)
        {
            case Idle:
                m_amplitude = 0.0;
                break;
            
            case Attack:
                if (m_attack <= 0)
                {
                    m_amplitude = 1.0;
                    m_state = Decay;
                }
                else
                {
                    m_amplitude = static_cast<double>(m_sample_index) / m_attack;
                    if (m_sample_index++ >= m_attack)
                    {
                        m_state = Decay;
                        m_sample_index = 0;
                    }
                }
                break;
            
            case Decay:
                if (m_decay <= 0)
                {
                    m_amplitude = m_sustain;
                    m_state = Sustain;
                }
                else
                {
                    double decay = static_cast<double>(m_sample_index) / m_decay;
                    m_amplitude = 1.0 + decay * (m_sustain - 1.0);
                    if (m_sample_index++ >= m_decay)
                    {
                        m_state = Sustain;
                    }
                }
                break;
            
            case Sustain:
                m_amplitude = m_sustain;
                break;
            
            case Release:
                if (m_release <= 0)
                {
                    m_amplitude = 0.0;
                    m_state = Idle;
                }
                else
                {
                    double release = static_cast<double>(m_sample_index) / m_release;
                    m_amplitude = m_release_amplitude * (1.0 - release);
                    if (m_sample_index++ >= m_release)
                    {
                        m_amplitude = 0.0;
                        m_state = Idle;
                    }
                }
                break;
        }
        return static_cast<float>(m_amplitude);
    }

private:
    enum State { Idle, Attack, Decay, Sustain, Release };

    double m_sample_rate = 48000.0;
    double m_attack = 0.0;
    double m_decay = 0.0;
    double m_sustain = 1.0;
    double m_release = 0.0;
    double m_amplitude = 0.0;
    double m_release_amplitude = 0.0;
    long m_sample_index = 0;
    State m_state = Idle;
};
